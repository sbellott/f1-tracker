generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

model User {
  id                  String        @id @default(cuid())
  email               String        @unique
  emailVerified       DateTime?
  password            String?
  pseudo              String?
  avatar              String?
  createdAt           DateTime      @default(now())
  updatedAt           DateTime      @updatedAt
  notifyBeforeSession Boolean       @default(true)
  notifyDelayMinutes  Int           @default(30)
  notifyEmail         Boolean       @default(true)
  notifyPush          Boolean       @default(false)
  notifyH24           Boolean       @default(true)
  notifyH1            Boolean       @default(true)
  notifyResults       Boolean       @default(true)
  darkMode            Boolean       @default(true)
  accounts            Account[]
  predictions         Prediction[]
  sessions            Session[]
  badges              UserBadge[]
  readArticles        ReadArticle[]
  notifications       Notification[]
  // Group relations
  ownedGroups         Group[]       @relation("GroupOwner")
  groupMemberships    GroupMember[]
  sentInvitations     GroupInvitation[] @relation("InvitationSender")
  receivedInvitations GroupInvitation[] @relation("InvitationRecipient")
  pushSubscriptions   PushSubscription[]

  @@map("users")
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@map("accounts")
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sessions")
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
  @@map("verification_tokens")
}

model Prediction {
  id              String      @id @default(cuid())
  userId          String
  raceId          String
  sessionType     SessionType @default(RACE)
  topTen          Json
  polePosition    String?
  fastestLap      String?
  points          Int?
  pointsBreakdown Json?
  createdAt       DateTime    @default(now())
  lockedAt        DateTime?
  race            Race        @relation(fields: [raceId], references: [id])
  user            User        @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, raceId, sessionType])
  @@map("predictions")
}

model Race {
  id           String        @id @default(cuid())
  season       Int
  round        Int
  name         String
  officialName String?
  circuitId    String
  date         DateTime
  hasSprint    Boolean       @default(false)
  resultsJson  Json?
  predictions  Prediction[]
  sessions     RaceSession[]
  circuit      Circuit       @relation(fields: [circuitId], references: [id])

  @@unique([season, round])
  @@map("races")
}

model RaceSession {
  id               String      @id @default(cuid())
  raceId           String
  type             SessionType
  dateTime         DateTime
  completed        Boolean     @default(false)
  canalPlusChannel String?
  isLive           Boolean     @default(true)
  resultsJson      Json?
  race             Race        @relation(fields: [raceId], references: [id], onDelete: Cascade)

  @@unique([raceId, type])
  @@map("race_sessions")
}

model Circuit {
  id              String           @id @default(cuid())
  ergastId        String           @unique
  name            String
  officialName    String?
  country         String
  city            String
  length          Float?
  turns           Int?
  lapRecord       String?
  lapRecordHolder String?
  lapRecordYear   Int?
  direction       String?
  firstGP         Int?
  drsZones        Int?
  trackImageUrl   String?
  facts           String?
  history         String?
  results         CircuitHistory[]
  races           Race[]

  @@map("circuits")
}

model CircuitHistory {
  id               String       @id @default(cuid())
  circuitId        String
  season           Int
  round            Int?
  raceName         String?
  raceDate         DateTime?
  winnerId         String?
  winnerConstructorId String?
  poleId           String?
  fastestLapId     String?
  winnerTime       String?
  fullResultsJson  Json?        // Complete race classification (all positions)
  syncedAt         DateTime     @default(now())
  circuit          Circuit      @relation(fields: [circuitId], references: [id])
  fastestLap       Driver?      @relation("CircuitFastestLap", fields: [fastestLapId], references: [id])
  pole             Driver?      @relation("CircuitPole", fields: [poleId], references: [id])
  winner           Driver?      @relation("CircuitWinner", fields: [winnerId], references: [id])
  winnerConstructor Constructor? @relation("CircuitWinnerConstructor", fields: [winnerConstructorId], references: [id])

  @@unique([circuitId, season])
  @@map("circuit_history")
}

model Driver {
  id                 String           @id @default(cuid())
  ergastId           String           @unique
  code               String
  number             Int?
  firstName          String
  lastName           String
  nationality        String
  dateOfBirth        DateTime?
  photoUrl           String?
  constructorId      String?
  totalRaces         Int              @default(0)
  totalWins          Int              @default(0)
  totalPodiums       Int              @default(0)
  totalPoles         Int              @default(0)
  totalFastestLaps   Int              @default(0)
  totalPoints        Float            @default(0)
  championships      Int              @default(0)
  circuitFastestLaps CircuitHistory[] @relation("CircuitFastestLap")
  circuitPoles       CircuitHistory[] @relation("CircuitPole")
  circuitWins        CircuitHistory[] @relation("CircuitWinner")
  constructor        Constructor?     @relation(fields: [constructorId], references: [id])
  standings          Standing[]
  raceResults        DriverRaceResult[]  // NEW: relation to race results
  careerInfo         DriverCareerInfo?   // NEW: relation to career info

  @@map("drivers")
}

model Constructor {
  id                String           @id @default(cuid())
  ergastId          String           @unique
  name              String
  shortName         String?
  nationality       String
  base              String?
  teamPrincipal     String?
  technicalDirector String?
  engine            String?
  color             String?
  logoUrl           String?
  totalWins         Int              @default(0)
  totalPodiums      Int              @default(0)
  totalPoles        Int              @default(0)
  championships     Int              @default(0)
  firstSeason       Int?
  drivers           Driver[]
  standings         Standing[]
  circuitWins       CircuitHistory[] @relation("CircuitWinnerConstructor")

  @@map("constructors")
}

model Standing {
  id            String       @id @default(cuid())
  season        Int
  round         Int
  type          StandingType
  position      Int
  driverId      String?
  constructorId String?
  points        Float
  wins          Int          @default(0)
  constructor   Constructor? @relation(fields: [constructorId], references: [id])
  driver        Driver?      @relation(fields: [driverId], references: [id])

  @@unique([season, round, type, driverId])
  @@unique([season, round, type, constructorId])
  @@map("standings")
}

model Badge {
  id          String      @id @default(cuid())
  code        String      @unique
  name        String
  description String
  icon        String
  condition   String
  users       UserBadge[]

  @@map("badges")
}

model UserBadge {
  id         String   @id @default(cuid())
  userId     String
  badgeId    String
  unlockedAt DateTime @default(now())
  raceId     String?
  badge      Badge    @relation(fields: [badgeId], references: [id])
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, badgeId])
  @@map("user_badges")
}

model NewsItem {
  id          String        @id @default(cuid())
  externalId  String        @unique
  source      String
  title       String
  summary     String?
  imageUrl    String?
  url         String
  publishedAt DateTime
  category    String?
  fetchedAt   DateTime      @default(now())
  readBy      ReadArticle[]

  @@index([publishedAt])
  @@map("news_items")
}

// Track which articles users have read
model ReadArticle {
  id         String    @id @default(cuid())
  userId     String
  articleId  String?   // Optional - only set if article is stored in NewsItem
  articleUrl String    // URL for external articles (always required for uniqueness)
  readAt     DateTime  @default(now())
  user       User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  newsItem   NewsItem? @relation(fields: [articleId], references: [id], onDelete: Cascade)

  @@unique([userId, articleUrl]) // Unique constraint on user + article URL
  @@index([userId])
  @@index([articleUrl])
  @@map("read_articles")
}

// NEW: Store driver race results (historical - never changes)
model DriverRaceResult {
  id              String   @id @default(cuid())
  driverId        String
  season          Int
  round           Int
  raceName        String
  circuitName     String
  date            DateTime
  position        Int
  positionText    String
  points          Float
  grid            Int
  laps            Int
  status          String
  time            String?
  fastestLap      Boolean  @default(false)
  fastestLapRank  Int?
  constructorId   String
  constructorName String
  syncedAt        DateTime @default(now())
  driver          Driver   @relation(fields: [driverId], references: [id], onDelete: Cascade)

  @@unique([driverId, season, round])
  @@index([driverId])
  @@index([season])
  @@map("driver_race_results")
}

// NEW: Store driver career info (historical milestones)
model DriverCareerInfo {
  id                  String   @id @default(cuid())
  driverId            String   @unique
  firstWinRace        String?
  firstWinSeason      Int?
  firstPoleRace       String?
  firstPoleSeason     Int?
  firstRaceRace       String?
  firstRaceSeason     Int?
  lastWinRace         String?
  lastWinSeason       Int?
  bestFinish          Int      @default(0)
  totalRacesFinished  Int      @default(0)
  totalRaces          Int      @default(0)
  totalDNFs           Int      @default(0)
  syncedAt            DateTime @default(now())
  driver              Driver   @relation(fields: [driverId], references: [id], onDelete: Cascade)

  @@map("driver_career_info")
}

// ============================================
// Group / League Models
// ============================================

model Group {
  id          String        @id @default(cuid())
  name        String
  description String?
  code        String        @unique // Unique invite code (e.g., "F1FANS2026")
  imageUrl    String?
  isPrivate   Boolean       @default(true)
  maxMembers  Int           @default(50)
  season      Int           @default(2026)
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt
  ownerId     String
  owner       User          @relation("GroupOwner", fields: [ownerId], references: [id], onDelete: Cascade)
  members     GroupMember[]
  invitations GroupInvitation[]

  @@index([code])
  @@index([ownerId])
  @@map("groups")
}

model GroupMember {
  id        String      @id @default(cuid())
  groupId   String
  userId    String
  role      GroupRole   @default(MEMBER)
  joinedAt  DateTime    @default(now())
  group     Group       @relation(fields: [groupId], references: [id], onDelete: Cascade)
  user      User        @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([groupId, userId])
  @@index([groupId])
  @@index([userId])
  @@map("group_members")
}

model GroupInvitation {
  id          String           @id @default(cuid())
  groupId     String
  senderId    String
  recipientId String?          // Optional: if inviting existing user by ID
  email       String?          // Optional: if inviting by email
  status      InvitationStatus @default(PENDING)
  createdAt   DateTime         @default(now())
  expiresAt   DateTime
  respondedAt DateTime?
  group       Group            @relation(fields: [groupId], references: [id], onDelete: Cascade)
  sender      User             @relation("InvitationSender", fields: [senderId], references: [id], onDelete: Cascade)
  recipient   User?            @relation("InvitationRecipient", fields: [recipientId], references: [id], onDelete: Cascade)

  @@index([groupId])
  @@index([email])
  @@index([recipientId])
  @@map("group_invitations")
}

enum GroupRole {
  OWNER
  ADMIN
  MEMBER
}

enum InvitationStatus {
  PENDING
  ACCEPTED
  REJECTED
  EXPIRED
}

enum SessionType {
  FP1
  FP2
  FP3
  SPRINT_QUALIFYING
  SPRINT
  QUALIFYING
  RACE
}

enum StandingType {
  DRIVER
  CONSTRUCTOR
}

// ============================================
// Notification System
// ============================================

model Notification {
  id          String           @id @default(cuid())
  userId      String
  type        NotificationType
  title       String
  message     String
  data        Json?            // Additional data (raceId, sessionType, etc.)
  read        Boolean          @default(false)
  sentAt      DateTime         @default(now())
  readAt      DateTime?
  emailSent   Boolean          @default(false)
  pushSent    Boolean          @default(false)
  user        User             @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([type])
  @@index([sentAt])
  @@map("notifications")
}

model NotificationSchedule {
  id          String           @id @default(cuid())
  raceId      String
  sessionType SessionType
  type        NotificationType
  scheduledAt DateTime
  processedAt DateTime?
  status      ScheduleStatus   @default(PENDING)
  
  @@unique([raceId, sessionType, type])
  @@index([scheduledAt])
  @@index([status])
  @@map("notification_schedules")
}

model ScoringJob {
  id           String       @id @default(cuid())
  raceId       String
  sessionType  SessionType
  status       JobStatus    @default(PENDING)
  startedAt    DateTime?
  completedAt  DateTime?
  error        String?
  processed    Int          @default(0)
  total        Int          @default(0)
  createdAt    DateTime     @default(now())

  @@unique([raceId, sessionType])
  @@index([status])
  @@map("scoring_jobs")
}

enum NotificationType {
  PREDICTION_REMINDER_H24
  PREDICTION_REMINDER_H1
  RESULTS_AVAILABLE
  SCORING_COMPLETE
  BADGE_UNLOCKED
  GROUP_INVITATION
  GROUP_UPDATE
  SYSTEM
}

enum ScheduleStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
}

enum JobStatus {
  PENDING
  RUNNING
  COMPLETED
  FAILED
}

// Push notification subscriptions for web push
model PushSubscription {
  id        String   @id @default(cuid())
  userId    String
  endpoint  String   @unique
  p256dh    String   // Public key for encryption
  auth      String   // Auth secret
  userAgent String?  // Browser/device info
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("push_subscriptions")
}